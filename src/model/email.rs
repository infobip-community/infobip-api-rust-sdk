use serde_derive::{Deserialize, Serialize};
use validator::Validate;

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Validate)]
#[serde(rename_all = "camelCase")]
pub struct SendRequestBody {
    /// Email address with optional sender name. This field is required if `templateId` is not
    /// present.
    #[serde(skip_serializing_if = "Option::is_none")]
    #[validate(email)]
    pub from: Option<String>,

    /// Email address of the recipient.
    #[validate(email)]
    pub to: String,

    /// CC recipient email address.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cc: Option<String>,

    /// BCC recipient email address.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bcc: Option<String>,

    /// Message subject. This field is required if `templateId` is not present.
    #[serde(skip_serializing_if = "Option::is_none")]
    #[validate(length(min = 1, max = 150))]
    pub subject: Option<String>,

    /// Body of the message.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<String>,

    /// HTML body of the message. If `html` and `text` fields are present, the `text` field will be
    /// ignored and `html` will be delivered as a message body.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub html: Option<String>,

    /// Template ID used for generating email content. The template is created over Infobip web
    /// interface. If `templateId` is present, then `html` and `text` values are ignored.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template_id: Option<i32>,

    /// File attachment.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attachment: Option<String>,

    /// Allows for inserting an image file inside the HTML code of the email by using
    /// `cid:FILENAME` instead of providing an external link to the image.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub inline_image: Option<String>,

    /// The real-time Intermediate delivery report that will be sent on your callback server.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub intermediate_report: Option<bool>,

    /// The URL on your callback server on which the Delivery report will be sent.
    #[serde(skip_serializing_if = "Option::is_none")]
    #[validate(url)]
    pub notify_url: Option<String>,

    /// Preferred Delivery report content type. Can be `application/json` or `application/xml`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub notify_content_type: Option<String>,

    /// Additional client data that will be sent on the notifyUrl.
    #[serde(skip_serializing_if = "Option::is_none")]
    #[validate(length(max = 4000))]
    pub callback_data: Option<String>,

    /// Enable or disable open and click tracking. Passing true will only enable tracking and the
    /// statistics would be visible in the web interface alone. This can be explicitly overridden
    /// by `trackClicks` and `trackOpens`. Default: true.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub track: Option<bool>,

    /// This parameter enables or disables track click feature.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub track_clicks: Option<bool>,

    /// This parameter enables or disables track opens feature.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub track_opens: Option<bool>,

    /// The URL on your callback server on which the open and click notifications will be sent.
    /// See Tracking Notifications for details.
    #[serde(skip_serializing_if = "Option::is_none")]
    #[validate(url)]
    pub tracking_url: Option<String>,

    /// The ID uniquely identifies the sent email request. This filter will enable you to query
    /// delivery reports for all the messages using just one request. You will receive a `bulkId`
    /// in the response after sending an email request. If you don't set your own `bulkId`, unique
    /// ID will be generated by our system and returned in the API response. (Optional Field)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bulk_id: Option<String>,

    /// The ID that uniquely identifies the message sent to a recipient. (Optional Field)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message_id: Option<String>,

    /// Email address to which recipients of the email can reply.
    #[serde(skip_serializing_if = "Option::is_none")]
    #[validate(email)]
    pub reply_to: Option<String>,

    /// General placeholder, given in a form of json example:
    /// `defaultPlaceholders={"ph1": "Success"}`, which will replace given key `{{ph1}}` with
    /// given value `Success` anywhere in the email (subject, text, html...). In case of more
    /// destinations in `To` field, this placeholder will resolve the same value for key `ph1`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_placeholders: Option<String>,

    /// If set to `true`, the `to` recipients will see the list of all other recipients to get the
    /// email and the response will return only one `messageId`. Otherwise, each recipient will
    /// see just their own email and the response will return a unique `messageId` for each email
    /// recipient.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub preserve_recipients: Option<bool>,

    /// To schedule message at a given time in future. Time provided should be in UTC in the
    /// following format: `yyyy-MM-dd'T'HH:mm:ss.SSSZ`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub send_at: Option<String>,

    /// Personalize opt out landing page by inserting placeholders. Insert placeholder or tag while
    /// designing landing page.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub landing_page_placeholders: Option<String>,

    /// Opt out landing page which will be used and displayed once end user clicks the unsubscribe
    /// link. If not present default opt out landing page will be displayed. Create a landing page
    /// on IBâ€™s portal and use the last 6 digits from URL to use that opt out page.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub landing_page_id: Option<String>,
}

impl SendRequestBody {
    pub fn new(to: String) -> Self {
        SendRequestBody {
            from: None,
            to,
            cc: None,
            bcc: None,
            subject: None,
            text: None,
            html: None,
            template_id: None,
            attachment: None,
            inline_image: None,
            intermediate_report: None,
            notify_url: None,
            notify_content_type: None,
            callback_data: None,
            track: None,
            track_clicks: None,
            track_opens: None,
            tracking_url: None,
            bulk_id: None,
            message_id: None,
            reply_to: None,
            default_placeholders: None,
            preserve_recipients: None,
            send_at: None,
            landing_page_placeholders: None,
            landing_page_id: None,
        }
    }
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SentMessageDetails {
    /// The destination address of the message.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub to: Option<String>,

    /// The ID that uniquely identifies a message response.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message_id: Option<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<Status>,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Status {
    /// Status group ID.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub group_id: Option<i32>,

    /// Status group name.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub group_name: Option<String>,

    /// Status ID.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<i32>,

    /// Status name.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Status description.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SendResponseBody {
    /// The ID that uniquely identifies a list of message responses.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bulk_id: Option<String>,

    /// List of message response details.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub messages: Option<Vec<SentMessageDetails>>,
}
